---
title: 优先队列(堆)
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---

## 引言

普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。通常采用堆数据结构来实现。

优先队列包括最大优先队列和最小优先队列，优先队列的应用比较广泛，比如作业系统中的调度程序，当一个作业完成后，需要在所有等待调度的作业中选择一个优先级最高的作业来执行，并且也可以添加一个新的作业到作业的优先队列中。

## 一些简单的实现

有几种明显的方法实现优先队列。我们可以使用一个简单的链表在表头以O(1)执行插入操作，并遍历该链表以删除最小元素需要O(N)时间。另一种方法是，始终让表保持有序的状态，这使得插入的代价高昂O(N)而删除的花费低廉O(1)。一般删除的操作小于等于插入的操作所以前者可能更好一些。

再有一种方法实现优先队列的方法是使用二叉查找树，它对这种操作的平均运行时间都是O(log N)。频繁的删除会破坏树的平衡。

## 二叉堆（binary heap）
二叉堆是一种优先级队列(priority queue)的实现。二叉查找树维护了全部数据结构的有序性，而在我们不需要得知全局有序，仅仅需要全局的极值时，这样是一种没有必要的浪费。根据对象的优先级进行访问的方式，称为循优先级访问(call-by-priority)。优先级队列本身并不是一个队列结构，而是根据优先级始终查找并访问优先级最高数据项的数据结构。

### 结构性质

在二叉堆的数组中，每个元素都要保证大于等于另外两个特定位置的元素。相应地，这些位置的元素又要大于等于数组中另外两个元素，以此类推。这种结构可以画成二叉树的样子。当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。根结点是堆有序的二叉树中的最大结点。这种堆称为大顶堆。相反地，我们可以定义小顶堆。

![](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538545129367.png)

用完全二叉树表示二叉堆特别方便，如上图所示，每个结点都大于等于它的两个子结点。

用数组实现完全二叉树也很简单。因此我们可以直接用数组来实现二叉堆。具体方法是，数组的第一个位置a[0]不使用（为了计算简单），根结点存在a[1]，然后按照层级顺序将二叉树结点依次放入数组中。如下所示a[2]、a[3]是根结点的两个子结点，且都小于根结点，而a[2]和a[3]的子结点分别在在数组中的位置4、5和6、7，以此类推。

![](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538545201716.png)

可以观察到规律：位置为$k$的结点，其左孩子结点的位置是$2k$，右孩子结点的位置是$2k+1$；其父结点的位置是$⌊k/2⌋$。一棵大小为N的完全二叉树的高度是$⌊lg N⌋$  

我们希望在对堆的操作过程中（如插入元素和删除最大元素）都保持着堆的状态不被打破——即保持二叉堆中每个结点大于等于它两个子结点的状态，为此每次插入元素或者删除最大元素后都需要一些操作来恢复被打破的状态，这个过程称为堆的有序化。堆的有序化是通过**上浮**和**下沉**两个操作完成的。


### 插入

插入操作是将一个元素插入到集合S中，首先把该元素放入所有元素的下一个位置，然后执行“上浮”操作，如下图示例

![小堆插入](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538547241957.png)

### 删除

优先队列中，在队列非空情况下移除集合中第一个元素，也就是下标为0的元素，然后将集合中最后一个元素移到下标为0位置，在将下标为0的新元素执行“下沉”操作。

![小堆删除](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538547293796.png)

### 堆排序



堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。

![实例](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538547716541.png)

堆排序的基本思想是：
1. 将待排序序列构造成一个大顶堆，
2. 整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了

这里面关键的就是如何构建二项堆，如果使用插入则会浪费一部分空间，可以不使用额外的空间，直接对其进行调整得到堆结构




## Referen

[博客1](https://www.cnblogs.com/luoxn28/p/5616101.html)

[博客2](https://www.cnblogs.com/sun-haiyu/p/7800109.html)

[堆排序](https://www.cnblogs.com/MOBIN/p/5374217.html)