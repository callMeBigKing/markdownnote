---
title: 优先队列(堆)
tags: 新建,模板,小书匠
grammar_cjkRuby: true
---

## 引言

普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。通常采用堆数据结构来实现。

优先队列包括最大优先队列和最小优先队列，优先队列的应用比较广泛，比如作业系统中的调度程序，当一个作业完成后，需要在所有等待调度的作业中选择一个优先级最高的作业来执行，并且也可以添加一个新的作业到作业的优先队列中。

## 一些简单的实现

有几种明显的方法实现优先队列。我们可以使用一个简单的链表在表头以O(1)执行插入操作，并遍历该链表以删除最小元素需要O(N)时间。另一种方法是，始终让表保持有序的状态，这使得插入的代价高昂O(N)而删除的花费低廉O(1)。一般删除的操作小于等于插入的操作所以前者可能更好一些。

再有一种方法实现优先队列的方法是使用二叉查找树，它对这种操作的平均运行时间都是O(log N)。频繁的删除会破坏树的平衡。

## 二叉堆（binary heap）
二叉堆是一种优先级队列(priority queue)的实现。二叉查找树维护了全部数据结构的有序性，而在我们不需要得知全局有序，仅仅需要全局的极值时，这样是一种没有必要的浪费。根据对象的优先级进行访问的方式，称为循优先级访问(call-by-priority)。优先级队列本身并不是一个队列结构，而是根据优先级始终查找并访问优先级最高数据项的数据结构。

### 结构性质

在二叉堆的数组中，每个元素都要保证大于等于另外两个特定位置的元素。相应地，这些位置的元素又要大于等于数组中另外两个元素，以此类推。这种结构可以画成二叉树的样子。当一棵二叉树的每个结点都大于等于它的两个子结点时，它被称为堆有序。根结点是堆有序的二叉树中的最大结点。这种堆称为大顶堆。相反地，我们可以定义小顶堆。

![](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538545129367.png)

用完全二叉树表示二叉堆特别方便，如上图所示，每个结点都大于等于它的两个子结点。

用数组实现完全二叉树也很简单。因此我们可以直接用数组来实现二叉堆。具体方法是，数组的第一个位置a[0]不使用（为了计算简单），根结点存在a[1]，然后按照层级顺序将二叉树结点依次放入数组中。如下所示a[2]、a[3]是根结点的两个子结点，且都小于根结点，而a[2]和a[3]的子结点分别在在数组中的位置4、5和6、7，以此类推。

![](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538545201716.png)

可以观察到规律：位置为$k$的结点，其左孩子结点的位置是$2k$，右孩子结点的位置是$2k+1$；其父结点的位置是$⌊k/2⌋$。一棵大小为N的完全二叉树的高度是$⌊lg N⌋$  

我们希望在对堆的操作过程中（如插入元素和删除最大元素）都保持着堆的状态不被打破——即保持二叉堆中每个结点大于等于它两个子结点的状态，为此每次插入元素或者删除最大元素后都需要一些操作来恢复被打破的状态，这个过程称为堆的有序化。堆的有序化是通过**上浮**和**下沉**两个操作完成的。


### 插入

插入操作是将一个元素插入到集合S中，首先把该元素放入所有元素的下一个位置，然后执行“上浮”操作，如下图示例

![小堆插入](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538547241957.png)

### 删除

优先队列中，在队列非空情况下移除集合中第一个元素，也就是下标为0的元素，然后将集合中最后一个元素移到下标为0位置，在将下标为0的新元素执行“下沉”操作。

![小堆删除](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538547293796.png)

### 堆排序



堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。首先简单了解下堆结构。

![实例](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538547716541.png)

算法思想(以大顶堆为例)：
1.将长度为n的待排序的数组进行堆有序化构造成一个大顶堆
 
2.将根节点与尾节点交换并输出此时的尾节点
 
3.将剩余的n -1个节点重新进行堆有序化
 
4.重复步骤2，步骤3直至构造成一个有序序列

假设待排序数组为[20,50,10,30,70,20,80]

**构造堆**
构造堆，反序遍历所有非叶子节点X，调整节点X和其子节点，使其满足最大堆

以[20,50,10,30,70,20,80] 初始状态

![初始状态](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538550024125.png)


第一次for循环将节点3和它的子节点7 8的元素进行比较，最大者作为父节点（即元素60作为父节点）
【红色表示交换后的状态】

![第一次循环](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538550059419.png)

第二次for循环将节点2和它的子节点5 6的元素进行比较，最大者为父节点（元素80作为父节点）

![第二次循环](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538550084174.png)

第三次for循环将节点1和它的子节点3 4的元素进行比较，最大者为父节点（元素70作为父节点）

![第三次循环](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538550102279.png)


第四次for循环将节点0和它的子节点1 2的元素进行比较，最大者为父节点（元素80作为父节点）

![第四次循环](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538550119381.png)

至此有序堆已经构造好了！如下图：

![大顶堆](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538550138475.png)

**排序过程**

（1）堆顶元素80和尾40交换后-->调整堆

![找到最大元素](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538550182531.png)

（2）堆顶元素70和尾30交换后-->调整堆

![](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538550211583.png)

堆顶元素60尾元素20交换后-->调整堆

![](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538550223666.png)

（4）其他依次类推，最终已排好序的元素如下：

![](https://hosbimkimg.oss-cn-beijing.aliyuncs.com/pic/1538550241022.png)

## Referen

[博客1](https://www.cnblogs.com/luoxn28/p/5616101.html)

[博客2](https://www.cnblogs.com/sun-haiyu/p/7800109.html)

[堆排序](https://www.cnblogs.com/MOBIN/p/5374217.html)